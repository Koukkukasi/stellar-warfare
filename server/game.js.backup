const Bot = require('./bot');

class Game {
  constructor(id, io, tickRate = 60) {
    this.id = id;
    this.io = io;
    this.tickRate = tickRate;
    this.tickInterval = 1000 / tickRate;
    this.tickTimer = null;
    this.lastTickTime = Date.now();

    // Game state
    this.players = new Map(); // socketId -> player object
    this.bots = new Map(); // botId -> bot object
    this.projectiles = [];
    this.asteroids = [];
    this.powerups = [];

    // Game config
    this.worldSize = { width: 4000, height: 3000 };
    this.maxPlayers = 10;
    this.gameStartTime = null;
    this.isRunning = false;

    // Initialize game world
    this.initializeWorld();
  }

  initializeWorld() {
    // Spawn asteroids
    const asteroidCount = 50;
    for (let i = 0; i < asteroidCount; i++) {
      this.asteroids.push({
        id: `asteroid_${i}`,
        x: Math.random() * this.worldSize.width,
        y: Math.random() * this.worldSize.height,
        radius: 20 + Math.random() * 40,
        velocityX: (Math.random() - 0.5) * 2,
        velocityY: (Math.random() - 0.5) * 2,
        rotation: Math.random() * Math.PI * 2,
        rotationSpeed: (Math.random() - 0.5) * 0.05
      });
    }
  }

  start() {
    this.isRunning = true;
    this.gameStartTime = Date.now();
    this.lastTickTime = Date.now();

    // Start game loop
    this.tickTimer = setInterval(() => this.tick(), this.tickInterval);

    console.log(`Game ${this.id} started`);
  }

  stop() {
    this.isRunning = false;
    if (this.tickTimer) {
      clearInterval(this.tickTimer);
      this.tickTimer = null;
    }
    console.log(`Game ${this.id} stopped`);
  }

  tick() {
    const now = Date.now();
    const deltaTime = (now - this.lastTickTime) / 1000; // Convert to seconds
    this.lastTickTime = now;

    // Update bots AI
    this.bots.forEach(bot => {
      bot.update(this.getGameState(), deltaTime);
    });

    // Update player physics
    this.players.forEach(player => {
      this.updatePlayerPhysics(player, deltaTime);
    });

    // Update bot physics
    this.bots.forEach(bot => {
      this.updatePlayerPhysics(bot, deltaTime);
    });

    // Update projectiles
    this.updateProjectiles(deltaTime);

    // Update asteroids
    this.updateAsteroids(deltaTime);

    // Check collisions
    this.checkCollisions();

    // Clean up dead entities
    this.cleanupDeadEntities();

    // Broadcast game state to all players
    this.broadcastGameState();
  }

  updatePlayerPhysics(entity, deltaTime) {
    // Apply acceleration
    entity.velocityX += Math.cos(entity.rotation) * entity.acceleration * deltaTime;
    entity.velocityY += Math.sin(entity.rotation) * entity.acceleration * deltaTime;

    // Apply drag
    const drag = 0.98;
    entity.velocityX *= drag;
    entity.velocityY *= drag;

    // Limit max speed
    const speed = Math.sqrt(entity.velocityX ** 2 + entity.velocityY ** 2);
    if (speed > entity.maxSpeed) {
      entity.velocityX = (entity.velocityX / speed) * entity.maxSpeed;
      entity.velocityY = (entity.velocityY / speed) * entity.maxSpeed;
    }

    // Update position
    entity.x += entity.velocityX * deltaTime * 60;
    entity.y += entity.velocityY * deltaTime * 60;

    // Wrap around world boundaries
    if (entity.x < 0) entity.x += this.worldSize.width;
    if (entity.x > this.worldSize.width) entity.x -= this.worldSize.width;
    if (entity.y < 0) entity.y += this.worldSize.height;
    if (entity.y > this.worldSize.height) entity.y -= this.worldSize.height;

    // Reset acceleration for next tick
    entity.acceleration = 0;

    // Update weapon cooldown
    if (entity.weaponCooldown > 0) {
      entity.weaponCooldown -= deltaTime;
    }
  }

  updateProjectiles(deltaTime) {
    this.projectiles = this.projectiles.filter(projectile => {
      // Update position
      projectile.x += projectile.velocityX * deltaTime * 60;
      projectile.y += projectile.velocityY * deltaTime * 60;

      // Decrease lifetime
      projectile.lifetime -= deltaTime;

      // Remove if expired or out of bounds
      return projectile.lifetime > 0 &&
             projectile.x >= 0 && projectile.x <= this.worldSize.width &&
             projectile.y >= 0 && projectile.y <= this.worldSize.height;
    });
  }

  updateAsteroids(deltaTime) {
    this.asteroids.forEach(asteroid => {
      asteroid.x += asteroid.velocityX * deltaTime * 60;
      asteroid.y += asteroid.velocityY * deltaTime * 60;
      asteroid.rotation += asteroid.rotationSpeed;

      // Wrap around boundaries
      if (asteroid.x < -asteroid.radius) asteroid.x = this.worldSize.width + asteroid.radius;
      if (asteroid.x > this.worldSize.width + asteroid.radius) asteroid.x = -asteroid.radius;
      if (asteroid.y < -asteroid.radius) asteroid.y = this.worldSize.height + asteroid.radius;
      if (asteroid.y > this.worldSize.height + asteroid.radius) asteroid.y = -asteroid.radius;
    });
  }

  checkCollisions() {
    // Player/Bot vs Projectile collisions
    const allEntities = [...this.players.values(), ...this.bots.values()];

    this.projectiles.forEach(projectile => {
      allEntities.forEach(entity => {
        if (projectile.ownerId !== entity.id && !entity.isDead) {
          const dx = entity.x - projectile.x;
          const dy = entity.y - projectile.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < 20) { // Hit detection radius
            // Damage player
            entity.health -= projectile.damage;
            projectile.lifetime = 0; // Mark projectile for removal

            if (entity.health <= 0) {
              entity.isDead = true;
              entity.health = 0;

              // Award kill to shooter
              const shooter = this.players.get(projectile.ownerId) || this.bots.get(projectile.ownerId);
              if (shooter) {
                shooter.kills++;
                shooter.score += 100;
              }

              entity.deaths++;
            }
          }
        }
      });
    });

    // Player/Bot vs Asteroid collisions
    allEntities.forEach(entity => {
      if (!entity.isDead) {
        this.asteroids.forEach(asteroid => {
          const dx = entity.x - asteroid.x;
          const dy = entity.y - asteroid.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < asteroid.radius + 20) {
            // Damage from asteroid collision
            entity.health -= 5;
            if (entity.health <= 0) {
              entity.isDead = true;
              entity.health = 0;
              entity.deaths++;
            }
          }
        });
      }
    });
  }

  cleanupDeadEntities() {
    // Respawn dead players after delay
    const respawnDelay = 3; // seconds

    this.players.forEach(player => {
      if (player.isDead) {
        player.respawnTimer = (player.respawnTimer || 0) + (1 / this.tickRate);
        if (player.respawnTimer >= respawnDelay) {
          this.respawnPlayer(player);
        }
      }
    });

    this.bots.forEach(bot => {
      if (bot.isDead) {
        bot.respawnTimer = (bot.respawnTimer || 0) + (1 / this.tickRate);
        if (bot.respawnTimer >= respawnDelay) {
          this.respawnPlayer(bot);
        }
      }
    });
  }

  respawnPlayer(player) {
    player.x = Math.random() * this.worldSize.width;
    player.y = Math.random() * this.worldSize.height;
    player.velocityX = 0;
    player.velocityY = 0;
    player.rotation = Math.random() * Math.PI * 2;
    player.health = 100;
    player.isDead = false;
    player.respawnTimer = 0;
  }

  addPlayer(socketId, socket, playerData) {
    const player = {
      id: socketId,
      socket: socket,
      name: playerData.name || `Player${socketId.substring(0, 4)}`,
      isBot: false,
      x: Math.random() * this.worldSize.width,
      y: Math.random() * this.worldSize.height,
      velocityX: 0,
      velocityY: 0,
      rotation: Math.random() * Math.PI * 2,
      acceleration: 0,
      maxSpeed: 300,
      health: 100,
      maxHealth: 100,
      isDead: false,
      score: 0,
      kills: 0,
      deaths: 0,
      weaponCooldown: 0
    };

    this.players.set(socketId, player);

    // Send initial game state to player
    socket.join(this.id);
    socket.emit('gameJoined', {
      gameId: this.id,
      playerId: socketId,
      worldSize: this.worldSize
    });
  }

  addBot() {
    const botId = `bot_${Date.now()}_${Math.random().toString(36).substring(7)}`;
    const bot = new Bot(botId, {
      x: Math.random() * this.worldSize.width,
      y: Math.random() * this.worldSize.height,
      rotation: Math.random() * Math.PI * 2
    });

    this.bots.set(botId, bot);
  }

  removePlayer(socketId) {
    this.players.delete(socketId);
  }

  hasPlayer(socketId) {
    return this.players.has(socketId);
  }

  getPlayerCount() {
    return this.players.size;
  }

  handlePlayerInput(socketId, input) {
    const player = this.players.get(socketId);
    if (!player || player.isDead) return;

    // Handle movement
    if (input.thrust) {
      player.acceleration = 500;
    }

    // Handle rotation
    if (input.rotateLeft) {
      player.rotation -= 0.1;
    }
    if (input.rotateRight) {
      player.rotation += 0.1;
    }

    // Handle shooting
    if (input.shoot && player.weaponCooldown <= 0) {
      this.spawnProjectile(player);
      player.weaponCooldown = 0.25; // 4 shots per second max
    }
  }

  spawnProjectile(owner) {
    const projectileSpeed = 600;
    const projectile = {
      id: `proj_${Date.now()}_${Math.random()}`,
      ownerId: owner.id,
      x: owner.x + Math.cos(owner.rotation) * 25,
      y: owner.y + Math.sin(owner.rotation) * 25,
      velocityX: Math.cos(owner.rotation) * projectileSpeed + owner.velocityX,
      velocityY: Math.sin(owner.rotation) * projectileSpeed + owner.velocityY,
      damage: 20,
      lifetime: 2.0 // seconds
    };

    this.projectiles.push(projectile);
  }

  getGameState() {
    return {
      worldSize: this.worldSize,
      players: Array.from(this.players.values()).map(p => ({
        id: p.id,
        name: p.name,
        x: p.x,
        y: p.y,
        rotation: p.rotation,
        health: p.health,
        maxHealth: p.maxHealth,
        isDead: p.isDead,
        score: p.score,
        kills: p.kills,
        deaths: p.deaths
      })),
      bots: Array.from(this.bots.values()).map(b => ({
        id: b.id,
        name: b.name,
        x: b.x,
        y: b.y,
        rotation: b.rotation,
        health: b.health,
        maxHealth: b.maxHealth,
        isDead: b.isDead,
        score: b.score,
        kills: b.kills,
        deaths: b.deaths,
        isBot: true
      })),
      projectiles: this.projectiles.map(p => ({
        id: p.id,
        x: p.x,
        y: p.y
      })),
      asteroids: this.asteroids.map(a => ({
        id: a.id,
        x: a.x,
        y: a.y,
        radius: a.radius,
        rotation: a.rotation
      }))
    };
  }

  broadcastGameState() {
    const state = this.getGameState();
    this.io.to(this.id).emit('gameState', state);
  }

  broadcastChatMessage(senderId, message) {
    const sender = this.players.get(senderId);
    if (sender) {
      this.io.to(this.id).emit('chatMessage', {
        playerId: senderId,
        playerName: sender.name,
        message: message,
        timestamp: Date.now()
      });
    }
  }
}

module.exports = Game;
